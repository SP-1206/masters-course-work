
 Named variables include
 function names (which are visible globally),
 array names (which are visible globally),
 parameters (which are only visible in the declared function) and
 identifiers in let statements (which are only visible in the expression associated with the let statement – which may in turn contain a let statement)



To accomplish this task, you will add actions to your YACC grammar from part I
 To keep track of symbols encountered, you will have to implement a data structure that keeps track of the visible names for all currently active scopes during the parsing process
 As the parsing process encounters a new scope, this information needs to be added and any identifiers declared are recorded in this scope (and checked to make sure they are not duplicates)
 The use of identifiers within a scope must be checked against the
current symbol table to see if the name is valid
 As a scope is exited, all information about that scope is discarded


find a scope -
stack_push_scope
stack_scope_init
init the scope table - init_table
add_to_table



If, during the parse of a MinLisp program, you encountered a duplicate declaration or a variable that is not declared, a message about this should be printed out, along with the associated line number
 Processing should continue (you don't have to do anything special for this to happen)
 Be sure your error messages are informative





 ML		:	arrays program   {super_scope.parent=NULL; init_table(super_scope.table);}
      ;
 arrays		:	arrays array
 					|
          ;
 array		:	LEFT_PARAM ARRAY IDENTIFIER NUMBERS RIGHT_PARAM {add_to_table(super_scope.table,$3,$4);}
          ;
 program		:	program function {scope_stack_head++;stack_scope_init(scope_stack[scope_stack_head],super_scope);init_table(scope_stack[scope_stack_head].table);}
 		|	function {scope_stack_head++;stack_scope_init(scope_stack[scope_stack_head],super_scope);init_table(scope_stack[scope_stack_head].table);}
 		;
 function	:	LEFT_PARAM DEFINE IDENTIFIER param_list expr RIGHT_PARAM {add_to_table(superscope.table,$3,0);scope_stack_head--;}
 ;
 param_list	:	LEFT_PARAM RIGHT_PARAM
 			|	LEFT_PARAM id_list RIGHT_PARAM
 			;
 id_list		:	id_list IDENTIFIER add_to_table(scope_stack[scope_stack_head],$2,0);
 		|	IDENTIFIER  add_to_table(scope_stack[scope_stack_head],$1,0);
 ;

 expr		: NUMBERS
 		|	IDENTIFIER
 		|	IDENTIFIER LEFT_SQUARE expr RIGHT_SQUARE
 		|	TRUE
 		|	FALSE
 		|	LEFT_PARAM IF expr expr expr RIGHT_PARAM
  	|	LEFT_PARAM WHILE expr expr RIGHT_PARAM
 		|	LEFT_PARAM IDENTIFIER actual_list RIGHT_PARAM
  	|	LEFT_PARAM WRITE expr RIGHT_PARAM
 		|	LEFT_PARAM WRITELN expr RIGHT_PARAM
 		|	LEFT_PARAM READ RIGHT_PARAM
  	|	LEFT_PARAM LET LEFT_PARAM assign_list RIGHT_PARAM expr RIGHT_PARAM {scope_stack_head++;stack_scope_init(scope_stack[scope_stack_head],scope_stack[scope_stack_head-1]);init_table(scope_stack[scope_stack_head].table);}
 		|	LEFT_PARAM SET IDENTIFIER expr RIGHT_PARAM
 		|	LEFT_PARAM SET IDENTIFIER LEFT_SQUARE expr RIGHT_SQUARE expr RIGHT_PARAM
  	|	LEFT_PARAM PLUS expr expr RIGHT_PARAM
 		|	LEFT_PARAM MINUS expr expr RIGHT_PARAM
  	|	LEFT_PARAM MULTIPLY expr expr RIGHT_PARAM
 		|	LEFT_PARAM DIVISION expr expr RIGHT_PARAM
 		|	LEFT_PARAM GREATER_THAN expr expr RIGHT_PARAM
 		|	LEFT_PARAM GREATER_THAN_OR_EQUAL_TO expr expr RIGHT_PARAM
  	|	LEFT_PARAM LESS_THAN expr expr RIGHT_PARAM
 		|	LEFT_PARAM LESS_THAN_OR_EQUAL_TO expr expr RIGHT_PARAM
  	|	LEFT_PARAM EQUAL expr expr RIGHT_PARAM
 		|	LEFT_PARAM NOT_EQUAL_TO expr expr RIGHT_PARAM
  	|	LEFT_PARAM MINUS expr RIGHT_PARAM
 		|	LEFT_PARAM AND  expr expr RIGHT_PARAM
 		|	LEFT_PARAM AND_SYMBOL  expr expr RIGHT_PARAM
  	|	LEFT_PARAM OR  expr expr RIGHT_PARAM
 		|	LEFT_PARAM OR_SYMBOL  expr expr RIGHT_PARAM
 		|	LEFT_PARAM NOT expr RIGHT_PARAM
 		|	LEFT_PARAM NOT_SYMBOL expr RIGHT_PARAM
    | LEFT_PARAM SEQ expr_list RIGHT_PARAM
 		;
 actual_list	:	actual_list expr
 		|
 		;
 assign_list	:	assign_list LEFT_PARAM IDENTIFIER expr RIGHT_PARAM {add_to_table(scope_stack[scope_stack_head],$3,$4);}
 		|	LEFT_PARAM IDENTIFIER expr RIGHT_PARAM  {add_to_table(scope_stack[scope_stack_head],$2,$3);scope_stack_head--;}
 		;
 expr_list       :    expr_list expr
 		|	expr
 		;




Project 4 -
    There are sixteen 64-bit registers in x86-64:
     ​%rax​,
     ​%rbx​,
     ​%rcx​,
     ​%rdx​,
     ​%rdi​,
     ​%rsi​,
     ​%rbp​,
     %rsp​,
     %r8
     %r9
     %r10
     %r11
     %r12
     %r13
     %r14
     %r15​


     Of these,
     ​%rax​,  - caller-save registers
     ​%rcx​,  - caller-save registers
     ​%rdx​,  - caller-save registers
     ​%rdi​,  - caller-save registers
     ​%rsi​,  - caller-save registers
     ​%rsp​,  - caller-save registers
      ​%r8  - caller-save registers
      %r9  - caller-save registers
      %r10  - caller-save registers
      %r11  - caller-save registers
     ​%rax​ - return value,
    (Larger return types like structs are returned using the stack.)
     ​%rbx​ - callee-save registers
     %rbp​ - callee-save registers
     ​%r12 - callee-save registers
     %r13 - callee-save registers
     %r14 - callee-save registers
     %r15 - callee-save registers
     saved across function calls.
     ​%rsp​ - ​stackpointer a pointer to the top most element in the stack.
    ​
     ​%rdi​ - 1st param
    ​ %rsi​ - 2nd param
     ​%rdx​ - 3rd param
     ​%rcx​ - 4th param
     ​%r8 - 5th param
     ​%r9​  - 6th param




    In 32-bit x86,
     the ​base pointer​ (formerly ​%ebp​,
     now​ ​%rbp​) was used to keep track of the base of the current stack frame,
     and a called function would save the base pointer of its caller prior to updating the base pointer to its own stack frame. With the advent of the 64-bit architecture,
     this has been mostly eliminated,
     save for a few special cases when the compiler cannot determine ahead of time how much stack space needs to be allocated for a particular function (see Dynamic stack allocation).


add a new type called register to the structure - things will break fix them
this was to add some breathing space for variables in the future.
build a huge register array
implement function get_free_register, - check if you need to split based on type





Getting this working for constants means that if you deal with variables by loading them into registers, all of work of computing expressions with identifiers is already done\.

%ebp causes a crash? - interesting - investigate and fix

%r10d
%r11d
%ebx
%ebp
%r12d
%r13d
%r14d
%r15d
